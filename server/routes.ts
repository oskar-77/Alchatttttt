import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { 
  insertUserSchema, 
  insertSessionSchema, 
  insertEmotionAnalysisSchema,
  insertChatMessageSchema,
  type EmotionData
} from "@shared/schema";
import { aiProviderManager } from "./ai-providers";

export async function registerRoutes(app: Express): Promise<Server> {
  
  // Create or get user
  app.post("/api/users", async (req, res) => {
    try {
      const userData = insertUserSchema.parse(req.body);
      
      // Check if user already exists
      const existingUser = await storage.getUserByName(userData.name);
      if (existingUser) {
        return res.json(existingUser);
      }
      
      const user = await storage.createUser(userData);
      res.json(user);
    } catch (error) {
      res.status(400).json({ error: "Invalid user data" });
    }
  });

  // Create session
  app.post("/api/sessions", async (req, res) => {
    try {
      const sessionData = insertSessionSchema.parse(req.body);
      
      // End any existing active session for this user
      const existingSession = await storage.getActiveSessionByUserId(sessionData.userId!);
      if (existingSession) {
        await storage.updateSession(existingSession.id, { 
          isActive: false, 
          endTime: new Date() 
        });
      }
      
      const session = await storage.createSession(sessionData);
      res.json(session);
    } catch (error) {
      res.status(400).json({ error: "Invalid session data" });
    }
  });

  // Get session
  app.get("/api/sessions/:id", async (req, res) => {
    const session = await storage.getSession(req.params.id);
    if (!session) {
      return res.status(404).json({ error: "Session not found" });
    }
    res.json(session);
  });

  // Save emotion analysis
  app.post("/api/emotions", async (req, res) => {
    try {
      const emotionData = insertEmotionAnalysisSchema.parse(req.body);
      const analysis = await storage.createEmotionAnalysis(emotionData);
      res.json(analysis);
    } catch (error) {
      res.status(400).json({ error: "Invalid emotion data" });
    }
  });

  // Get emotion analyses for session
  app.get("/api/sessions/:sessionId/emotions", async (req, res) => {
    const analyses = await storage.getEmotionAnalysesBySession(req.params.sessionId);
    res.json(analyses);
  });

  // Send chat message with AI response
  app.post("/api/chat", async (req, res) => {
    try {
      const messageData = insertChatMessageSchema.parse(req.body);
      
      // Save user message
      const userMessage = await storage.createChatMessage(messageData);
      
      // Generate AI response with emotional context
      const emotionContext = messageData.emotionContext as EmotionData;
      const { response: aiResponse, provider } = await aiProviderManager.generateResponse(
        messageData.content, 
        emotionContext
      );
      
      console.log(`AI response generated by: ${provider}`);
      
      // Save AI response
      const aiMessage = await storage.createChatMessage({
        sessionId: messageData.sessionId,
        isUser: false,
        content: aiResponse,
        emotionContext: emotionContext
      });
      
      res.json({ userMessage, aiMessage, provider });
    } catch (error) {
      console.error("Chat error:", error);
      res.status(500).json({ error: "Failed to process chat message" });
    }
  });

  // Get chat messages for session
  app.get("/api/sessions/:sessionId/messages", async (req, res) => {
    const messages = await storage.getChatMessagesBySession(req.params.sessionId);
    res.json(messages);
  });

  // Get session statistics
  app.get("/api/sessions/:sessionId/stats", async (req, res) => {
    const sessionId = req.params.sessionId;
    const emotions = await storage.getEmotionAnalysesBySession(sessionId);
    const messages = await storage.getChatMessagesBySession(sessionId);
    const session = await storage.getSession(sessionId);
    
    if (!session) {
      return res.status(404).json({ error: "Session not found" });
    }

    // Calculate statistics
    const totalDetections = emotions.length;
    const averageConfidence = emotions.length > 0 
      ? Math.round(emotions.reduce((sum, e) => sum + (e.confidence || 0), 0) / emotions.length)
      : 0;
    
    // Calculate dominant emotion
    const emotionTotals: Record<string, number> = {};
    emotions.forEach(analysis => {
      const emotions = analysis.emotions as EmotionData;
      Object.entries(emotions).forEach(([emotion, value]) => {
        emotionTotals[emotion] = (emotionTotals[emotion] || 0) + value;
      });
    });
    
    const dominantEmotion = Object.entries(emotionTotals).length > 0
      ? Object.entries(emotionTotals).reduce((a, b) => a[1] > b[1] ? a : b)[0]
      : 'neutral';

    // Calculate session duration
    const duration = session.isActive && session.startTime
      ? Math.floor((Date.now() - session.startTime.getTime()) / 1000)
      : session.endTime && session.startTime
      ? Math.floor((session.endTime.getTime() - session.startTime.getTime()) / 1000)
      : 0;

    res.json({
      duration,
      detections: totalDetections,
      averageConfidence,
      dominantEmotion,
      messageCount: messages.length,
      latestEmotions: emotions.slice(-1)[0]?.emotions || null
    });
  });

  // Get available AI providers with enhanced status
  app.get("/api/ai-providers", async (req, res) => {
    try {
      const providers = aiProviderManager.getAvailableProviders();
      
      // Add enhanced status information
      const enhancedProviders = providers.map(provider => ({
        ...provider,
        status: provider.configured ? 'active' : 'inactive',
        lastTest: new Date().toISOString(),
        description: 'Ù…Ø²ÙˆØ¯ Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªÙ‚Ø¯Ù…'
      }));
      
      res.json(enhancedProviders);
    } catch (error) {
      console.error('Error fetching providers:', error);
      res.status(500).json({ error: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø²ÙˆØ¯ÙŠÙ†' });
    }
  });

  // Enhanced Test AI Provider endpoint with better error handling
  app.post('/api/test-ai-provider', async (req, res) => {
    const startTime = Date.now();
    try {
      const { provider: providerName, message, emotions } = req.body;
      console.log(`ğŸ§ª Testing AI Provider: ${providerName || 'auto'}`);
      
      if (!message || !emotions) {
        return res.status(400).json({
          success: false,
          error: 'Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± ÙˆØ§Ù„Ù…Ø´Ø§Ø¹Ø± Ù…Ø·Ù„ÙˆØ¨Ø©'
        });
      }
      
      const { response: aiResponse, provider } = await aiProviderManager.generateResponse(
        message,
        emotions
      );

      const responseTime = Date.now() - startTime;
      console.log(`âœ… Test completed in ${responseTime}ms`);

      res.json({
        success: true,
        response: aiResponse,
        provider,
        responseTime,
        timestamp: new Date().toISOString()
      });
    } catch (error: any) {
      const responseTime = Date.now() - startTime;
      console.error(`âŒ Test failed after ${responseTime}ms:`, error);
      
      res.json({
        success: false,
        error: error.message || 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù…Ø²ÙˆØ¯ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ',
        responseTime,
        timestamp: new Date().toISOString()
      });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}

// Removed - using aiProviderManager instead
